unit classUnits;

interface
uses classTile, GameValues,
    Classes, FMX.StdCtrls, FMX.Types, FMX.Objects, FMX.Graphics, FMX.Layouts;

type
  // TUnit is abstract class - DO NOT USE
  // Can't make this actually abstract it seems? just the methods
  TUnit = class(TRectangle)
  private
    Tile : TTile;
    Selection : TCircle;
    Image: TImage;
    // Visual representation of remaining movement as colored circles
    MovementCircles : Array of TCircle;
    AttackCircles   : Array of TCircle;
    layCircles : TLayout;

    Team : Integer;
    isSelected : Boolean;

    HP   : Integer; // 0 HP and unit dies
    MP   : Integer; // Move Points left
    AP   : Integer; // Points left that can do actions

    MaxHP: Integer;
    MaxMP: Integer; // Max Move Points
    MaxAP: Integer; // Max Action Points
    DAM  : Integer; // Damage to enemy HP when attacking
    Range: Integer; // Range of attack (1 range can attack adjacent tiles)

    procedure OnUnitClick(Sender : TObject);
    procedure FriendlyClick;
    procedure HostileClick;
  published

    constructor Create(AOwner : TComponent; newTeam : Integer);
    procedure Select;
    procedure Deselect;
    procedure Move(Destination : TTile; Cost : Integer);
    procedure SetMP(newValue : Integer);
    procedure Attack(Target : TUnit);
    procedure SetAP(newValue : Integer);
    procedure RecieveHit(Damage : Integer);
    procedure Die;

    procedure EndTurn;
  end;

  // TODO destructor

  TSword = class(TUnit)
  published
    constructor Create(AOwner : TComponent);
  end;

implementation
uses Main;

  procedure TUnit.OnUnitClick(Sender : TObject);
  begin
    if Team = 1 then FriendlyClick
    else if Team = 2 then HostileClick;
  end;

  procedure TUnit.FriendlyClick;
  begin
    Deselect;
    Select;
  end;

  procedure TUnit.HostileClick;
  begin
    //
  end;

  constructor TUnit.Create(AOwner : TComponent; newTeam : Integer);
  var
    I: Integer;
    Circle : TCircle;
  begin
    Inherited Create(AOwner);

    Team := Team;

    Fill.Color := ColorNull;
    Stroke.Kind := TBrushKind.None;

    Align := TAlignLayout.Center;
    Width  := TileWidth - (UnitMargins*2);
    Height := TileHeight - (UnitMargins*2);
    Visible := True;
    OnClick := OnUnitClick;

    // Selection circle
    Selection := TCircle.Create(Self);
    Selection.Parent := Self;
    Selection.Align := TAlignLayout.Contents;
    Selection.Fill.Kind := TBrushKind.None;
    Selection.Stroke.Thickness := ThicknessUnselected;
    if Team = 1 then Selection.Stroke.Color := ColorTeam1
    else
    if Team = 2 then Selection.Stroke.Color := ColorTeam2
    else Selection.Stroke.Color := ColorTeam3;
    Selection.OnClick := OnUnitClick;
    isSelected := False;

    // Create layout where point circles go (bottom of unit)
    layCircles := TLayout.Create(Self);
    layCircles.Parent := Self;

    layCircles.Align := TAlignLayout.Bottom;
    layCircles.Height := CircleSize;
    layCircles.Margins.Left := CircleLayoutMargins;
    layCircles.Margins.Right := CircleLayoutMargins;
    layCircles.Margins.Bottom := CircleLayoutMargins;
    layCircles.Visible := True;

    // Create movement point circles (bottom left of unit)
    SetLength(MovementCircles, MaxMP);
    for I := 0 to MaxMP-1 do
    begin
      Circle := TCircle.Create(layCircles);
      Circle.Parent := layCircles;
      Circle.Fill.Color := ColorMovementCircle;

      Circle.Align:= TAlignLayout.Left;
      Circle.Width := CircleSize;
      Circle.Height:= CircleSize;
      Circle.Margins.Left := CircleMargins;
      Circle.Margins.Right:= CircleMargins;
      Circle.Visible := True;

      Circle.OnClick := OnUnitClick;

      MovementCircles[I] := Circle;
    end;

    // Create attack point circles (bottom right of unit)
    SetLength(AttackCircles, MaxAP);
    for I := 0 to MaxAP-1 do
    begin
      Circle := TCircle.Create(layCircles);
      Circle.Parent := layCircles;
      Circle.Fill.Color := ColorAttackCircle;

      Circle.Align := TAlignLayout.Right;
      Circle.Width := CircleSize;
      Circle.Height := CircleSize;
      Circle.Margins.Left := CircleMargins;
      Circle.Margins.Left := CircleMargins;
      Circle.Visible := True;

      Circle.OnClick := OnUnitClick;

      AttackCircles[I] := Circle;
    end;

    Image := TImage.Create(Self);
    Image.Parent := Self;
    Image.Align  := TAlignLayout.Contents;
    Image.Margins.Left := ImageMargins;
    Image.Margins.Right:= ImageMargins;
    Image.Margins.Top := ImageMargins;
    Image.Margins.Bottom := ImageMargins;
    Image.Visible:= True;
    Image.OnClick := OnUnitClick;
    Image.SendToBack;
  end;

  procedure TUnit.Select;
  begin
    IsSelected := True;
    SelectedUnit := Self;
    Selection.Stroke.Thickness := ThicknessSelected;
    Tile.DistFromSelected := 0;
    Tile.ShowTilesWithinRange(MP);
  end;

  procedure TUnit.Deselect;
  begin
    IsSelected := False;
    SelectedUnit := nil;
    Selection.Stroke.Thickness := ThicknessUnselected;

    World.ClearAvailableMoves;
    World.ClearDistances;
  end;

  // Move unit to destination tile
  // Cost is cost to move points
  procedure TUnit.Move(Destination : TTile; Cost : Integer);
  var
    X : Single;
    Y : Single;
  begin
    Tile := Destination;
    Parent := Tile;

    X := Position.X;
    Y := Position.Y;

    SetMP(MP - Cost);
  end;

  procedure TUnit.SetMP(newValue: Integer);
  var
    I: Integer;
  begin
    MP := newValue;

    for I := 0 to Length(MovementCircles)-1 do
    begin
      if newValue > 0 then MovementCircles[I].Visible := True
      else MovementCircles[I].Visible := False;
      newValue := newValue - 1;
    end;
  end;

  procedure TUnit.Attack(Target: TUnit);
  begin
    Target.RecieveHit(DAM);
    AP := AP - 1;
  end;

  procedure TUnit.SetAP(newValue: Integer);
  var
    I: Integer;
  begin
    AP := newValue;

    for I := 0 to Length(AttackCircles)-1 do
    begin
      if newValue > 0 then AttackCircles[I].Visible := True
      else AttackCircles[I].Visible := False;
      newValue := newValue - 1;
    end;
  end;

  procedure TUnit.RecieveHit(Damage: Integer);
  begin
    HP := HP - Damage;
    if HP < 0 then
    begin
      Die;
    end;
  end;

  procedure TUnit.Die;
  begin
    Tile := nil;
    Image.Free;
  end;

  procedure TUnit.EndTurn;
  begin
    MP := MaxMP;
    AP := MaxAP;
  end;

  constructor TSword.Create(AOwner: TComponent);
  begin
    HP    := SwordHP;
    MP    := SwordMP;
    AP    := SwordAP;

    MaxHP := SwordHP;
    MaxMP := SwordMP;
    MaxAP := SwordAP;
    DAM   := SwordDAM;
    Range := SwordRange;

    Inherited Create(AOwner);

    Image.Bitmap.Assign(MainForm.imageSword.Bitmap);
  end;

end.
